\chapter{Design}
It is assumed that there is central token handler, that issues tokens when a deposit is made into a wallet of a node. Producers can also exchange there tokens for currency at the token handler.

It is also assumed that some form of hardware that can measure electricity consumption and report back to the blockchain node. Transmission lines and other aspects related to the transfer of electricity is not part of the scope for this thesis.

\section{Blockchain Module}
Class for blocks

Class for blockchain

Genesis
Validation
hashlib.sha256 for hashes 

\section{Network Module}
Peer to Peer network implemented with Python framework Twisted. Asynchronous. Event based. The initial node starts a server and connects to itself. Other nodes connect to a server already running on a given port. Hello message is sent from node trying to connect and receives and hello ack if connection is successful. Connecting node receives a list of peers from the node it connected to and tries to connect to them in the same manner.

Send hello
Ack hello
Start ping
Respond with pong
If 3 pings unresponded - remove peer
Also drop peer in peer list if connection is dropped and notified

Connecting node receives other peers in network, connects to peers and repeat above process until no unconnected peers or max peers connected
Starts a new client for every peer it connects to
Peers receive connections on server if they are being connected to
Reactor
Deferreds, callback and errback chain


Lock for transactions?

No protection against brute force attacks on network

Store all peers since finite size of network?
\section{Node Module}
%Make float chart
Initial node starts blockchain
Connecting nodes compare local head block to peer
If not the same, receive blockchain if other peer has connecting peers head block in chain
Validate blockchain and query other peers for head block and receive blockchain if its not the same
When blockchains are the same start creating blocks
When new block created, it is proposed to the other peers, they validate block and accept it and sets it to be local head block 


\section{Consensus Module}
The consensus module used in this system is Raft. 

Raft - can handle fail-stop not Byzantine fails
Random Timeout
If no leader msg received before a timeout -> become leader
If no timeout - become candidate or follower (how many candidates?)
TX shared in local mempool - broadcasted to everyone
Leader proposes new block
Followers and candidates verify new block and respond to leader with vote
(Weigh votes, so nodes with tx in block are more weighted - stake)
Leader needs 2/3 of votes before broadcasting the new block
Each message/block from leader contains a term, if leader receives a message/block with higher term it becomes a follower instead. If fork, the side with the leader that holds the highest term will also hold the valid blockchain, the side of the fork with the invalid blockchain will switch, sending all transactions not accounted for back to the mempool

Validate TX by checking signature on smart contract or smart contract exists, sequence number, valid coins

\section{Smart Contracts}
%Turing complete